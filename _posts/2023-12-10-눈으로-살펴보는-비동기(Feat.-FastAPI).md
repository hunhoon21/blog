안녕하세요. 오랜만에 블로그 글을 작성합니다.

이번에 다룰 주제는 “비동기” 입니다. 이번 포스팅에서는 비동기/동기 API를 FastAPI 에서 구현하고 로그를 살펴볼 예정입니다. 이를 통해 비동기 작동을 눈으로 살펴보고 작동 흐름을 이해할 수 있기를 기대합니다. 

FastAPI Web Application 을 통해 API를 구현할 때, 동기 메서드와 비동기 메서드 차이를 명확히 이해하고 실제로 어떻게 작동하는지 파악하는데 도움이 되면 좋겠습니다.

마지막으로, 잘못 구현한 예시를 살펴보고 비동기 로직 작성시 하지 말아야할 실수를 알아봅니다.

* [비동기](#비동기-(Asynchronous))
* [사람들은 비동기를 왜 어려워할까?](#사람들은-비동기를-왜-어려워할까?)
* [비동기 작동 도식화](#비동기-작동-도식화)
* [FastAPI 에서의 비동기/동기 메서드](#FastAPI-에서의-비동기/동기-메서드)
* [비동기 눈으로 살펴보기](#비동기-눈으로-살펴보기)


# 비동기 (Asynchronous)

비동기 프로그래밍은 동시성과 효율성을 높이는 프로그래밍 방식입니다.

비동기 프로그래밍 을 통해 쓰레드가 “동시에” 여러가지 태스크들을 처리할 수 있고 이를 통해 효율성이 높아집니다. 특히 I/O 바운드 작업에서 그 진가를 발휘합니다.

실제 서비스 수준에서 무수히 많은 코드가 비동기 방식으로 작성되고, 이를 이해하는 것은 필수적이라고 할 수 있습니다.

## 사람들은 비동기를 왜 어려워할까?

- 동기에 비해 직관적이지 않아서?
- 데이터/로직의 흐름이 와닿지 않아서?
- 이벤트 루프 존재를 인지하고 있지 않아서?

비동기 프로그래밍은 로직 흐름을 직관적으로 이해하기 어려울 수 있습니다.

전통적인 동기 프로그래밍은 코드가 순차적으로 실행되는 반면, 비동기 프로그래밍은 여러 작업이 겹치거나 동시에 실행될 수 있기 때문입니다. 동시성에 대한 이해가 없다면 코드 추적을 하기 어렵습니다.

또 이벤트 루프에 대한 인지를 먼저하고 있지 않으면 이해가 더욱 어렵습니다.
특정 로직을 처리하기 위해 단순히 파일을 실행하는게 아니라, 이미 떠있던 이벤트 루프에 의해 태스크가 비동기로 처리되는 것입니다.
이를 이해하고 있으면 비동기의 흐름을 파악하는데 도움이 됩니다.

## 비동기 작동 흐름 이해하기

태스크를 비동기로 처리한다는 것을 정리해보면 다음과 같습니다.

### 비동기 작동 흐름 도식화
> <img src="https://github.com/hunhoon21/hunhoon21.github.io/assets/36983960/84097a1f-3c71-4a31-bcd1-78348b87e9c8" alt="async-logic" width="100%"/>

- event 루프가 떠있고, 현재 쓰레드가 태스크를 기다립니다.
- 현재 쓰레드는 주어지는 태스크를 “해야하는 만큼” 수행합니다.
    - task1 이 주어졌다고 가정합니다.
    - task1 을 수행합니다.
    - task1 수행 도중 시스템에게 맡길 일을 만납니다. (ex. 파일쓰기, 네트워크 통신)
    - 시스템에게 일을 맡깁니다.
    - 이제 현재 쓰레드는 하는 일이 없습니다.
- 현재 쓰레드는 주어지는 다음 태스크를 “해야하는 만큼” 수행합니다.
    - task2 이 주어졌다고 가정합니다.
    - task2 을 수행합니다.
    - task2 수행 도중 시스템에게 맡길 일을 만납니다. (ex. 파일쓰기, 네트워크 통신)
    - 시스템에게 일을 맡깁니다.
    - 이제 현재 쓰레드는 하는 일이 없습니다.
- 위 과정을 반복합니다.

## FastAPI로 구현하는 테스트용 API

[FastAPI](https://fastapi.tiangolo.com/ko/)는 현대적이고, 빠르며(고성능), 파이썬 표준 타입 힌트에 기초한 Python3.6+의 API를 빌드하기 위한 웹 프레임워크입니다.

이번에 FastAPI를 통해 구현하는 API 총 3가지 입니다.
* 동기 API
* 비동기 API
* 비동기인데 동기 로직이 있는 API

위 API 들은 아래와 같은 특징이 있습니다.
* I/O Job을 모방하는 sleep 을 1초 수행합니다.
* Process ID, Thread ID를 로그에서 출력합니다. API 마다 프로세스/쓰레드가 어떻게 되는지 확인하기 위함입니다.
* 비동기 API 는 내부 구현 async 메서드도 타고 타고 호출하도록 합니다. 내부 구현 async 메서드를 호출할 때 만나는 await을 통해서도 멈추는지 확인하기 위함입니다.
* Client 입장에서 위에서 제공하는 API 중 한가지를 동시에 N 번 호출합니다.

위 내용을 정리한 그림은 다음과 같습니다.
### 테스트용 API 도식화
> <img src="https://github.com/hunhoon21/hunhoon21.github.io/assets/36983960/ba68f31f-b39b-44dc-865d-0484c77a51eb" alt="test-api" width="100%"/>

## 테스트용 API 소스코드


### 동기 API

```python
@app.get("/sync-endpoint")
def sync_endpoint():
    pid = os.getpid()
    thread_id = threading.get_ident()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /sync-endpoint just called."
    )

    sleep_time = 1
    start_time = time.time()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /sync-endpoint {sleep_time=}."
    )
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /sync-endpoint JUST NOW {start_time=}."
    )

    time.sleep(sleep_time)  # IO Job 모사하기

    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /sync-endpoint sleeped for {sleep_time=}."
    )

    elapsed_time = time.time() - start_time
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | Sync Endpoint, Sleep Time: {sleep_time} seconds, Elapsed Time: {elapsed_time:.2f} seconds"
    )
    return {"message": "Sync endpoint completed!", "duration": end_time - start_time}
```

### 비동기 API

```python
async def async_func_depth_2(sleep_time):
    pid = os.getpid()
    thread_id = threading.get_ident()
    print(f"Process ID: {pid} | Thread ID: {thread_id} | I'm just in depth 2")
    print(f"Process ID: {pid} | Thread ID: {thread_id} | Call ASYNC JOB to system!")
    await asyncio.sleep(sleep_time)  # 비동기 I/O를 흉내 내는 코드
    print(f"Process ID: {pid} | Thread ID: {thread_id} | Came back to depth 2")
    print(f"Process ID: {pid} | Thread ID: {thread_id} | depth 2 DONE")


async def async_func_depth_1(sleep_time):
    pid = os.getpid()
    thread_id = threading.get_ident()
    print(f"Process ID: {pid} | Thread ID: {thread_id} | I'm just in depth 1")
    print(f"Process ID: {pid} | Thread ID: {thread_id} | Call depth 2")
    await async_func_depth_2(sleep_time)
    print(f"Process ID: {pid} | Thread ID: {thread_id} | Came back to depth 1")
    print(f"Process ID: {pid} | Thread ID: {thread_id} | depth 1 DONE")


@app.get("/async-endpoint")
async def async_endpoint():
    pid = os.getpid()
    thread_id = threading.get_ident()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /async-endpoint just called."
    )

    sleep_time = 1
    start_time = time.time()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /async-endpoint {sleep_time=}."
    )
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /async-endpoint JUST NOW {start_time=}."
    )

    await async_func_depth_1(sleep_time=sleep_time)  # 비동기 I/O를 모사하는 코드

    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /async-endpoint await sleeped for {sleep_time=}."
    )

    elapsed_time = time.time() - start_time
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | Async Endpoint, Sleep Time: {sleep_time} seconds, Elapsed Time: {elapsed_time:.2f} seconds"
    )
    return {"message": "Async endpoint completed!", "duration": end_time - start_time}
```

### 비동기인데 동기 로직이 있는 API

```python
@app.get("/async-wrong")
async def async_wrong_endpoint():
    pid = os.getpid()
    thread_id = threading.get_ident()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | /async-wrong just called."
    )

    sleep_time = 1
    start_time = time.time()
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} |  /async-wrong {sleep_time=}."
    )
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} |  /async-wrong JUST NOW {start_time=}."
    )

    time.sleep(sleep_time)  # 비동기 API 에서 동기로 I/O 모사하는 코드

    print(
        f"Process ID: {pid} | Thread ID: {thread_id} |  /async-wrong wait sleeped for {sleep_time=}."
    )

    end_time = time.time()
    elapsed_time = end_time - start_time
    print(
        f"Process ID: {pid} | Thread ID: {thread_id} | Async-wrong Endpoint, Sleep Time: {sleep_time} seconds, Elapsed Time: {elapsed_time:.2f} seconds"
    )
    return {"message": "Async endpoint completed!", "duration": end_time - start_time}
```

### Client 구현

### 비동기 눈으로 살펴보기


