안녕하세요.
오늘은 IPython 프로젝트의 Jupyter Lab에서 돌아가는 쓰레드에 대해 아주 간단히 일부분 알아보도록 하겠습니다 ^^; 참고로 해당 쓰레드들은 `IPython`, `ipykernel` 라이브러리에 구현되어 있습니다.

최근에 회사에서 IPython이 제공하는 클래스를 커스터마이징하는 일이 필요했습니다. 그러다 보니 쥬피터 내부를 파악하는 일이 필요했는데요, 삽질하다 알게된 내용들이 흥미로워 공유하고자 합니다. (~~주절주절 주의~~)

쥬피터를 사용하시는 분들이라면 흥미롭게 읽을 수 있으실 수 있을 것 같습니다!

## 쥬피터에서 돌아가는 쓰레드 목록?
쥬피터에서 돌아가는 쓰레드 목록은 간단히 `threading.enumerate()` 명령어로 알아볼 수 있습니다. 아래 명령어를 쥬피터 랩 위에서 실행시켜 보세요.
```python
import threading
threading.enumerate()

# [<_MainThread(MainThread, started 4768542208)>,
#  <Thread(Thread-4, started daemon 123145466998784)>,
#  <Heartbeat(Thread-5, started daemon 123145483788288)>,
#  <Thread(Thread-6, started daemon 123145501650944)>,
#  <Thread(Thread-7, started daemon 123145518440448)>,
#  <ControlThread(Thread-3, started daemon 123145535229952)>,
#  <HistorySavingThread(IPythonHistorySavingThread, started 123145552019456)>,
#  <ParentPollerUnix(Thread-2, started daemon 123145569345536)>]
```

총 8개의 쓰레드가 있다는 것을 알 수 있습니다.
먼저 메인쓰레드는 당연히 1개가 존재합니다. 또, 이름이 붙은 `Heartbeat`, `ControlThread`, `HistorySavingThread`, `ParentPollerUnix` 쓰레드 4개가 존재합니다. 그리고 이름이 붙지 않은 `Threead-4`, `Thread-6`, `Thread-7` 쓰레드 3개가 존재하네요.

### Heartbeat 쓰레드
이름이 비교적 쉬운 `Heartbeat` 쓰레드입니다. `ipykernel.heartbeat.Heartbeat` 위치에 구현되어 있습니다. 구현체의 일부를 첨부합니다.
```python
# ipykernel/heartbeat.py
...
class Heartbeat(Thread):
    "A simple ping-pong style heartbeat that runs in a thread."

    def __init__(self, context, addr=None):
    ...
```
쥬피터에서는 ZeroMessageQueue(이하 ZMQ) 로 통신을 하는데, ZMQ가 잘 살아있는지 확인해주는 역할을 하는 녀석 같습니다. 주석에서 simple ping-pong 이라며 간단히 적혀있네요.

### ControlThread
`ControlThread` 는 `IOLoop` 를 실제로 실행시키는 역할을 합니다. 그래서 좀더 타고 들어가보면 `IPykernelApp`이 initialize() 하면서 등록을 하는 것을 확인할 수 있습니다. 아래는 소스코드 일부입니다.
```python
# ipykernel/control.py
...
class ControlThread(Thread):

    def __init__(self, **kwargs):
        Thread.__init__(self, **kwargs)
        self.io_loop = IOLoop(make_current=False)
        self.pydev_do_not_trace = True
        self.is_pydev_daemon_thread = True

    def run(self):
        self.io_loop.make_current()
        try:
            self.io_loop.start()
        ...
```

실제로 실행을 보면 `io_loop.start()` 를 하는것을 볼 수 있습니다.

### HistorySavingThread
`HistorySavingThread` 는 쥬피터에서의 History를 데이터베이스에 쓰는 역할을 합니다. 아래는 소스코드 일부입니다.
```python
# Ipython/core/history.py
...
class HistorySavingThread(threading.Thread):
    """This thread takes care of writing history to the database, so that
    the UI isn't held up while that happens.

    It waits for the HistoryManager's save_flag to be set, then writes out
    the history cache. The main thread is responsible for setting the flag when
    the cache size reaches a defined threshold."""
    daemon = True
    stop_now = False
    enabled = True
    ...
```

다만 쥬피터에서의 History가 명확하게 뭔지는 잘 모르겠네요 ㅎㅎ

### ParentPollerUnix
`ParentPollerUnix` 쓰레드는 유닉스계열에만 특화된 쓰레드로, 부모 프로세스가 존재하는 경우에 해당 프로세스를 삭제시켜주는 쓰레드로 파악됩니다. 아래는 소스코드 일부입니다.
```python
# ipykernel/parentpoller.py
...
class ParentPollerUnix(Thread):
    """ A Unix-specific daemon thread that terminates the program immediately
    when the parent process no longer exists.
    """

    def __init__(self):
        super(ParentPollerUnix, self).__init__()
        self.daemon = True

    def run(self):
        # We cannot use os.waitpid because it works only for child processes.
        from errno import EINTR
        while True:
            try:
                if os.getppid() == 1:
                    get_logger().warning("Parent appears to have exited, shutting down.")
                    os._exit(1)
                time.sleep(1.0)
            except OSError as e:
                if e.errno == EINTR:
                    continue
                raise
            ...
```

run 메서드 구현을 보면 process id가 1이 되는 경우에 해당 프로세스를 종료시키는 것으로 보입니다. 얕은 지식으로 알기로는.. 부모 프로세스가 먼저 죽는 경우는 자식 프로세스의 id가 1이 되는것으로 알고 있는데요. 그 경우를 처리하는 것이 아닌가 싶습니다.

### 나머지?
나머지는 이름이 없으니 어떤 구현체로 이루어져있는지 파악하기가 쉽지가 않습니다. 아래에서 쥬피터 실행 도중에 `tid` (쓰레드 id) 를 직접 찍어보고, `threading.enumerate()` 에서 보았던 `tid` 가 있는지 살펴보겠습니다!

## 쥬피터 실행 중 tid 살펴보기
